# بهینه‌سازی سرعت و عملکرد (Performance)

این سند نتیجهٔ بررسی کد از نظر **سرعت و Performance** است و پیشنهادهای عملی به‌همراه اولویت دارد.

---

## وضعیت فعلی (خلاصه)

| حوزه | وضعیت | توضیح کوتاه |
|------|--------|--------------|
| Session + DB | ⚠️ قابل بهبود | هر بار session، یک query برای avatar/user |
| API کش | ✅ خوب | recent-activity و چند API کش درخواست دارند |
| SWR / کش کلاینت | ✅ خوب | dedupe، refreshInterval، بعضی با کش طولانی‌تر |
| کوئری N+1 | ✅ کنترل‌شده | در feedback با Promise.all و یک query managers |
| لیست فیدبک | ⚠️ قابل بهبود | بدون virtualization؛ همه آیتم‌ها رندر می‌شوند |
| چارت‌ها | ✅ خوب | Recharts با dynamic import و lazy |
| تصاویر | ✅ خوب | next/image و optimized-image استفاده شده |

---

## ۱. Session و دیتابیس (اولویت بالا)

### مشکل
در **هر درخواستی که به session نیاز دارد**، داخل callback مربوط به `session` در `lib/auth.ts` یک بار `prisma.users.findUnique` برای گرفتن avatar و به‌روزرسانی name/email اجرا می‌شود. یعنی برای هر لود صفحه (و هر درخواست API که session بخواند) یک round-trip به DB اضافه است.

### پیشنهاد
- **گزینه A (ساده):** avatar را فقط وقتی واقعاً لازم است از API جداگانه بگیر (مثلاً در layout یا یک endpoint مثل `/api/users/me/avatar`). در session callback فقط از مقادیر JWT استفاده کن و دیگر برای هر session یک query نزن.
- **گزینه B:** اگر حتماً avatar در session می‌خواهی، آن را با یک **کش کوتاه‌مدت در حافظه** (مثلاً ۳۰–۶۰ ثانیه) به ازای هر `userId` نگه دار تا درخواست‌های پشت‌سرهم همان کاربر به DB نزنند.

**اثر:** کاهش قابل‌توجه تعداد query به دیتابیس و کمی سریع‌تر شدن هر درخواست.

---

## ۲. لیست فیدبک و Virtualization (اولویت بالا)

### مشکل
صفحه فیدبک (`app/feedback/page.tsx`) لیست را با `.map` رندر می‌کند. با تعداد زیاد فیدبک (مثلاً ۱۰۰+)، همهٔ ردیف‌ها در DOM ساخته می‌شوند و هم رندر اول و هم اسکرول می‌تواند سنگین شود.

### وضعیت فعلی
- کامپوننت‌های `VirtualList` و `virtual-table` در `components/ui/` وجود دارند ولی در صفحه فیدبک استفاده نشده‌اند.
- وابستگی `react-window` در پروژه هست.

### پیشنهاد
- لیست فیدبک را با **همان VirtualList یا virtual-table** پیاده کن: فقط آیتم‌های visible (و چند آیتم قبل/بعد) در DOM باشند.
- اگر لیست به صورت صفحه‌بندی (pagination) از API می‌آید، همان limit (مثلاً ۲۰–۵۰) را نگه دار و فقط برای همان صفحه از virtualization استفاده کن تا با ترکیب «pagination + virtualization» هم داده کم بیاید هم رندر سبک باشد.

**اثر:** رندر اول و اسکرول در لیست‌های بلند خیلی سبک‌تر می‌شود.

---

## ۳. درخواست‌های موازی در Dashboard (اولویت متوسط)

### وضعیت
- Dashboard با SWR چند منبع داده می‌گیرد: `useStats`، `useMyAssessmentResults`، `useSWR('/api/dashboard/upcoming-tasks')`.
- این‌ها به‌صورت موازی لود می‌شوند که خوب است.

### پیشنهاد
- یک **SWRConfig** سراسری با `dedupingInterval` و در صورت نیاز `revalidateOnFocus: false` برای داشبورد داشته باش تا در چند جای مختلف همان URL دوباره fetch نشود.
- برای `/api/dashboard/upcoming-tasks` و `/api/stats` اگر داده خیلی واقع‌زمانی لازم نیست، `refreshInterval` را بالاتر بگذار (مثلاً ۲–۵ دقیقه) تا درخواست کم‌تر شود.

**اثر:** کمی کمتر درخواست و مصرف شبکه.

---

## ۴. APIهای سنگین و کش سرور (اولویت متوسط)

### وضعیت خوب
- `recent-activity`: کش ۳۰ ثانیه در حافظه + هدر `Cache-Control: s-maxage=30, stale-while-revalidate=60`.
- الگوی مشابه در چند API دیگر.

### پیشنهاد
- برای APIهای دیگر **خواندنی و کم‌تغییر** (مثلاً `/api/departments`، `/api/user-statuses`، `/api/settings` در حالت فقط‌خواندن) هم:
  - یا کش در حافظه با TTL کوتاه (مثلاً ۱–۵ دقیقه)،
  - یا حداقل هدر `Cache-Control` با `s-maxage` و در صورت امکان `stale-while-revalidate` بگذار.
- از **lib/api-cache.ts** به‌صورت یکدست استفاده کن تا کلید و TTL متمرکز باشد.

**اثر:** کاهش بار دیتابیس و کمی پاسخ سریع‌تر برای داده‌های کم‌تغییر.

---

## ۵. کوئری‌های Prisma (اولویت متوسط)

### وضعیت
- در `app/api/feedback/route.ts` با `Promise.all` برای لیست + count و یک query جدا برای managers از N+1 جلوگیری شده.
- در بسیاری از routeها از `select` / `include` مشخص استفاده شده که خوب است.

### پیشنهاد
- در **همه** APIهایی که لیست با relation برمی‌گردانند، الگوی مشابه را رعایت کن: یک یا دو query با `select` محدود، بدون حلقهٔ `findUnique` روی هر آیتم.
- برای لیست‌های خیلی بزرگ، **cursor-based pagination** را در نظر بگیر (به‌جای offset) تا با افزایش صفحه، کند نشود.
- در production لاگ Prisma را فقط روی `error` بگذار (الان در `lib/prisma.ts` برای non-dev فقط `error` است؛ حفظش کن).

**اثر:** ثبات و سرعت بهتر در لیست‌های بزرگ و تحت بار.

---

## ۶. باندل و بار اول صفحه (اولویت متوسط)

### وضعیت
- استفاده از `next/dynamic` برای چارت‌ها، هدر، سایدبار، بعضی مودال‌ها.
- Recharts به‌صورت lazy لود می‌شود.

### پیشنهاد
- صفحاتی که فقط برای ادمین/مدیر باز می‌شوند (مثلاً analytics، ارزیابی‌ها) را با **dynamic import** برای خود صفحه لود کن تا باندل اولیه سبک‌تر شود:
  - `const AnalyticsPage = dynamic(() => import('@/app/analytics/page'))` و استفاده در routing اگر ساختار اجازه دهد، یا
  - با همان الگوی lazy که الان برای کامپوننت‌ها داری، بخش‌های سنگین را جدا بار کن.
- یک بار `npm run analyze` (اسکریپت موجود) اجرا کن و ماژول‌های خیلی بزرگ را شناسایی کن؛ در صورت امکان با dynamic یا جایگزینی کتابخانه سبک‌تر کوچک‌شان کن.

**اثر:** زمان بار اول و LCP بهتر، مخصوصاً روی شبکه‌های ضعیف.

---

## ۷. تصاویر (اولویت پایین)

### وضعیت
- استفاده از `next/image` و `components/ui/optimized-image.tsx`.

### پیشنهاد
- برای تصاویر آپلود کاربر (مثلاً avatar، تصویر فیدبک) حتماً از همان کامپوننت بهینه‌شده استفاده شود و در صورت امکان `sizes` مناسب برای layout موبایل/دسکتاپ تنظیم شود تا از بار اضافی تصویر جلوگیری شود.

**اثر:** مصرف پهنای باند و زمان بارگذاری تصاویر کمتر.

---

## ۸. مانیتورینگ و لاگ (اولویت پایین)

### وضعیت
- `lib/performance.ts`: تایمر، `measureQuery`، لاگ کندی کوئری (>۱ ثانیه).
- در بعضی APIها از `PerformanceTimer` استفاده شده (مثلاً users).

### پیشنهاد
- برای APIهای حیاتی (مثلاً لیست فیدبک، لاگین، آپلود) به‌صورت یکدست از **همان تایمر یا measureQuery** استفاده کن و در development یا با یک feature-flag در production، اگر زمان پاسخ از حدی (مثلاً ۵۰۰ms یا ۱s) بیشتر شد، یک بار در لاگ یا سرویس مانیتورینگ ثبت شود.
- در production از لاگ کردن body یا جزئیات خطا در پاسخ به کلاینت خودداری کن؛ فقط در سرور لاگ کن.

**اثر:** شناسایی زودتر کندی و رگ‌های قرمز عملکرد.

---

## خلاصه اولویت‌بندی

| اولویت | مورد | اثر تقریبی |
|--------|------|------------|
| بالا | حذف/کاهش query دیتابیس در session callback (avatar) | کمتر شدن بار DB و کمی سریع‌تر شدن هر درخواست |
| بالا | Virtualization برای لیست فیدبک | رندر و اسکرول سبک‌تر در لیست بلند |
| متوسط | کش و Cache-Control برای APIهای کم‌تغییر | کمتر شدن بار سرور و پاسخ سریع‌تر |
| متوسط | یکدست‌سازی SWR و کاهش refresh غیرضروری | کمتر درخواست و مصرف شبکه |
| متوسط | Pagination با cursor برای لیست‌های بزرگ و بررسی N+1 در بقیه APIها | پایداری و سرعت تحت بار |
| پایین | Lazy load صفحات/بخش‌های سنگین و تحلیل باندل | بهبود بار اول و LCP |
| پایین | مانیتورینگ زمان پاسخ API | تشخیص زودتر کندی |

اگر بخواهی می‌توانیم از یکی از موارد بالا (مثلاً session callback یا virtualization لیست فیدبک) مرحله‌به‌مرحله پیاده‌سازی را با کد مشخص پیش ببریم.
